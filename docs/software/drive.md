Drive Systems {#drive}
====================

## Structure
### Pose Estimator

The pose estimator is responsible for updating the robot's position and heading via dead reckoning or odometry.

### Targeter

The targeter is responsible for generating a target pose for the :ref:`controller <controller>` to go to.

.. _controller:

### Controller
A controller gets a target and an actual pose and returns a velocity vector and a heading vector.

### Localizer
The localizer gets a velocity and heading vector and updates the motor powers.

## Terminology

.. note::

    We currently rely on a PID system.

.. _pid_section:

### PID Controller
`PID <https://medium.com/autonomous-robotics/pid-control-85596db59f35>`_ stands for
`Proportional Integral Derivative <https://en.wikipedia.org/wiki/PID_controller>`_
and is used by our drive subsystem to maintain consistent speed
and ensure that slippage does not affect the movement of the robot.

:math:`p(t)=K_p e(t) + K_i \int_{0}^{t} e(t) \,dt + K_d \frac{de(t)}{dt}`

Where:

:math:`e(t)=\text{target}-\text{actual}` at time t.
The `target` is the desired value of the attribute, and the `actual` is the current value of the attribute.

:math:`p(t)` is the power (whether it be physical motor power or theoretical velocity) at time t.

The actual simply means the current state of the attribute, this is unlikely to be inaccurate. Target refers to the
desired state of the attribute. The attribute is an int/float that represents a physical quantity, the robot's angle, or even motor tick counts.
These can be measured in any unit, but millimeters, tick counts, or degrees are preferred by the team.

See Also: https://gm0.org/en/latest/docs/software/concepts/control-loops.html?highlight=PID#pid

### Feed Forward Controller

:math:`p(x, y)=K_a a(x, y) + K_v v(x, y)`

Where

:math:`p(x, y)` is the attribute value at location (x, y)

:math:`K_a` is a calibrated constant.

:math:`K_v` is a calibrated constant.

:math:`v(x, y)` is function for the velocity at location (x, y).

:math:`a(x, y)` is function for the acceleration at location (x, y).

Feedforward gives a faster response than PID when correcting for errors because it doesn't require an iteration to make a desicion.
However it does require predefined paths to follow for velocity and acceleration.
Such paths can be generated by motion profiles, which return a position, velocity, and acceleration.

### Holonomic Controller

A PID Controller is simply a one dimensional way to set a rate of change when provided with an error.
The holonomic controller calculates the motor speeds using 3 PIDs.
One for x movement, one for y movement, and one for theta movement.
The conversion from robot velocities to motor powers uses these formulas: https://gm0.org/en/latest/docs/software/tutorials/mecanum-drive.html

See also: https://www.ctrlaltftc.com/practical-examples/drivetrain-control#mecanum-drivetrain-controller


### Motion Profiling

Motion Profiles define a target velocity and acceleration.
The advantage of doing this is a reduction of slippage, as acceleration can be limited.
The simplest type of motion profile is a trapezoidal motion profile, which has a constant acceleration and deceleration.

See also: https://www.ctrlaltftc.com/advanced/motion-profiling

### Quintic Splines

Road Runner uses quintic splines to generate motion profiles. The quintic splines represent the location of the robot.
Road Runner takes the first and second derivatives of the quintic splines to generate the motion profile.
