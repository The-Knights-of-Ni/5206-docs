Software
=============

The code we write is in
`/TeamCode/src/main/java/org/firstinspires/ftc/teamcode/ <https://github.com/The-Knights-of-Ni/CenterStage/tree/master/TeamCode/src/main/java/org/firstinspires/ftc/teamcode>`_
and it is divided into multiple files for readability and usability.

.. toctree::
   :maxdepth: 1
   :caption: Contents:

   software/debugging
   software/build_systems
   javadoc


Op Modes
______________

The op modes (short for Operational Modes) are the different portions of the game:

Auto or Autonomous refers to the portion of the game the robot drives itself without interaction from the drivers,
this usually lasts 30 seconds.

The Teleop period starts directly after that, and lasts 2:30, drivers use 2 gamepads to send instructions to the robot.


Subsystems
___________

Control
^^^^^^^^^^^^^
The control subsystem controls.

Drive
^^^^^^^^
The drive subsystem controls the drive train of the robot.
See :ref:`pid_section` and :ref:`move_vector` for more info.

Vision
^^^^^^^^^
The vision subsystem controls all things vision. This includes the vision challenge for the season.
OpenCV is used, as there is no viable alternative (Vuforia is no longer supported and see below for tensorflow-lite).

Vision Strategies
~~~~~~~~~~~~~~~~~~~~~~

Single Object, Multiple Locations
***********************************

Use a threshold to isolate the object.
Then find the largest contour area and use that to determine the location of the object.

**Technical Details**
1. Use Gaussian Blur to remove noise (optional)
2. Convert to HSV
3. Core.inRange() to isolate the object
4. Use Imgproc.findContours() to find the contours of the object
5. See PowerPlay code if you're using color summing

Single Object, Single Location
***********************************

... Why would you need vision for this?
*April Tags* have known locations and unique ids, and you could determine the robot's location from one.

Multiple Objects, Multiple Locations
***************************************
Use a threshold to isolate the objects.
Then use the list of contour areas to get the locations of the objects; use April Tags to find absolute position if necessary.

Robot.java
___________

Contains all hardware setup and most subsystem configuration.

Drive Systems
_______________


.. note::

    We currently rely on a PID system.

.. _pid_section:

PID
^^^^^^
`PID <https://medium.com/autonomous-robotics/pid-control-85596db59f35>`_ stands for
`Proportional Integral Derivative <https://en.wikipedia.org/wiki/PID_controller>`_
and is used by our drive subsystem to maintain consistent speed
and ensure that slippage does not affect the movement of the robot.

:math:`p(t)=K_p e(t) + K_i \int_{0}^{t} e(t) \,dt + K_d \frac{de(t)}{dt}`

Where:

:math:`e(t)=\text{target}-\text{actual}` at time t.
The `target` is the desired value of the attribute, and the `actual` is the current value of the attribute.

:math:`p(t)` is the power (whether it be physical motor power or theoretical velocity) at time t.

The actual simply means the current state of the attribute, this is unlikely to be inaccurate. Target refers to the
desired state of the attribute. The attribute is an int/float that represents a physical quantity, the robot's angle, or even motor tick counts.
These can be measured in any unit, but millimeters, tick counts, or degrees are preferred by the team.

See Also: https://gm0.org/en/latest/docs/software/concepts/control-loops.html?highlight=PID#pid

Feed Forward
^^^^^^^^^^^^^^^^^^^^^
:math:`p(x, y)=K_a a(x, y) + K_v v(x, y)`

Where

:math:`p(x, y)` is the attribute value at location (x, y)

:math:`K_a` is a calibrated constant.

:math:`K_v` is a calibrated constant.

:math:`v(x, y)` is the velocity at location (x, y).

:math:`a(x, y)` is the acceleration at location (x, y).

Feedforward gives a faster response than PID when correcting for errors because it doesn't require an iteration to make a desicion.
However it does require predefined paths to follow for velocity and acceleration.
Such paths can be generated by motion profiles, which return a position, velocity, and acceleration.

Holonomic Control
^^^^^^^^^^^^^^^^^^^^^^^^
PIDs needs a way to talk to the motors. The holonomic controller calculates the motor speeds using 3 PIDs.
One for x movement, one for y movement, and one for theta movement.
The conversion from robot velocities to motor powers uses these formulas: https://gm0.org/en/latest/docs/software/tutorials/mecanum-drive.html

See also: https://www.ctrlaltftc.com/practical-examples/drivetrain-control#mecanum-drivetrain-controller


Motion Profiling
^^^^^^^^^^^^^^^^^^

Motion Profiles define a target velocity and acceleration.
The advantage of doing this is a reduction of slippage, as acceleration can be limited.
The simplest type of motion profile is a trapezoidal motion profile, which has a constant acceleration and deceleration.

See also: https://www.ctrlaltftc.com/advanced/motion-profiling

Quintic Splines
^^^^^^^^^^^^^^^^^^^^^^^^

Road Runner uses quintic splines to generate motion profiles. The quintic splines represent the location of the robot.
Road Runner takes the first and second derivatives of the quintic splines to generate the motion profile.

Useful Tools
___________________

`scrcpy <https://github.com/Genymobile/scrcpy>`_
